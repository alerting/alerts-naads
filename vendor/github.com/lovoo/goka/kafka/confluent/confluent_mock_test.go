// +build confluent

// Automatically generated by MockGen. DO NOT EDIT!
// Source: confluent.go

package confluent

import (
	kafka "github.com/confluentinc/confluent-kafka-go/kafka"
	gomock "github.com/golang/mock/gomock"
)

// Mock of confluentConsumer interface
type MockconfluentConsumer struct {
	ctrl     *gomock.Controller
	recorder *_MockconfluentConsumerRecorder
}

// Recorder for MockconfluentConsumer (not exported)
type _MockconfluentConsumerRecorder struct {
	mock *MockconfluentConsumer
}

func NewMockconfluentConsumer(ctrl *gomock.Controller) *MockconfluentConsumer {
	mock := &MockconfluentConsumer{ctrl: ctrl}
	mock.recorder = &_MockconfluentConsumerRecorder{mock}
	return mock
}

func (_m *MockconfluentConsumer) EXPECT() *_MockconfluentConsumerRecorder {
	return _m.recorder
}

func (_m *MockconfluentConsumer) Assign(partitions []kafka.TopicPartition) error {
	ret := _m.ctrl.Call(_m, "Assign", partitions)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockconfluentConsumerRecorder) Assign(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Assign", arg0)
}

func (_m *MockconfluentConsumer) Close() error {
	ret := _m.ctrl.Call(_m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockconfluentConsumerRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

func (_m *MockconfluentConsumer) Commit() ([]kafka.TopicPartition, error) {
	ret := _m.ctrl.Call(_m, "Commit")
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockconfluentConsumerRecorder) Commit() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Commit")
}

func (_m *MockconfluentConsumer) CommitMessage(m *kafka.Message) ([]kafka.TopicPartition, error) {
	ret := _m.ctrl.Call(_m, "CommitMessage", m)
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockconfluentConsumerRecorder) CommitMessage(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "CommitMessage", arg0)
}

func (_m *MockconfluentConsumer) CommitOffsets(offsets []kafka.TopicPartition) ([]kafka.TopicPartition, error) {
	ret := _m.ctrl.Call(_m, "CommitOffsets", offsets)
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockconfluentConsumerRecorder) CommitOffsets(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "CommitOffsets", arg0)
}

func (_m *MockconfluentConsumer) Events() chan kafka.Event {
	ret := _m.ctrl.Call(_m, "Events")
	ret0, _ := ret[0].(chan kafka.Event)
	return ret0
}

func (_mr *_MockconfluentConsumerRecorder) Events() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Events")
}

func (_m *MockconfluentConsumer) GetMetadata(topic *string, allTopics bool, timeoutMs int) (*kafka.Metadata, error) {
	ret := _m.ctrl.Call(_m, "GetMetadata", topic, allTopics, timeoutMs)
	ret0, _ := ret[0].(*kafka.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockconfluentConsumerRecorder) GetMetadata(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "GetMetadata", arg0, arg1, arg2)
}

func (_m *MockconfluentConsumer) Poll(timeoutMs int) kafka.Event {
	ret := _m.ctrl.Call(_m, "Poll", timeoutMs)
	ret0, _ := ret[0].(kafka.Event)
	return ret0
}

func (_mr *_MockconfluentConsumerRecorder) Poll(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Poll", arg0)
}

func (_m *MockconfluentConsumer) QueryWatermarkOffsets(topic string, partition int32, timeoutMs int) (int64, int64, error) {
	ret := _m.ctrl.Call(_m, "QueryWatermarkOffsets", topic, partition, timeoutMs)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

func (_mr *_MockconfluentConsumerRecorder) QueryWatermarkOffsets(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "QueryWatermarkOffsets", arg0, arg1, arg2)
}

func (_m *MockconfluentConsumer) String() string {
	ret := _m.ctrl.Call(_m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

func (_mr *_MockconfluentConsumerRecorder) String() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "String")
}

func (_m *MockconfluentConsumer) Subscribe(topic string, rebalanceCb kafka.RebalanceCb) error {
	ret := _m.ctrl.Call(_m, "Subscribe", topic, rebalanceCb)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockconfluentConsumerRecorder) Subscribe(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Subscribe", arg0, arg1)
}

func (_m *MockconfluentConsumer) SubscribeTopics(topics []string, rebalanceCb kafka.RebalanceCb) error {
	ret := _m.ctrl.Call(_m, "SubscribeTopics", topics, rebalanceCb)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockconfluentConsumerRecorder) SubscribeTopics(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SubscribeTopics", arg0, arg1)
}

func (_m *MockconfluentConsumer) Unassign() error {
	ret := _m.ctrl.Call(_m, "Unassign")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockconfluentConsumerRecorder) Unassign() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Unassign")
}

func (_m *MockconfluentConsumer) Unsubscribe() error {
	ret := _m.ctrl.Call(_m, "Unsubscribe")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockconfluentConsumerRecorder) Unsubscribe() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Unsubscribe")
}

// Automatically generated by MockGen. DO NOT EDIT!
// Source: github.com/lovoo/goka/kafka (interfaces: Consumer,TopicManager,Producer)

package mock

import (
	gomock "github.com/golang/mock/gomock"
	kafka "github.com/lovoo/goka/kafka"
)

// Mock of Consumer interface
type MockConsumer struct {
	ctrl     *gomock.Controller
	recorder *_MockConsumerRecorder
}

// Recorder for MockConsumer (not exported)
type _MockConsumerRecorder struct {
	mock *MockConsumer
}

func NewMockConsumer(ctrl *gomock.Controller) *MockConsumer {
	mock := &MockConsumer{ctrl: ctrl}
	mock.recorder = &_MockConsumerRecorder{mock}
	return mock
}

func (_m *MockConsumer) EXPECT() *_MockConsumerRecorder {
	return _m.recorder
}

func (_m *MockConsumer) AddGroupPartition(_param0 int32) {
	_m.ctrl.Call(_m, "AddGroupPartition", _param0)
}

func (_mr *_MockConsumerRecorder) AddGroupPartition(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "AddGroupPartition", arg0)
}

func (_m *MockConsumer) AddPartition(_param0 string, _param1 int32, _param2 int64) error {
	ret := _m.ctrl.Call(_m, "AddPartition", _param0, _param1, _param2)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockConsumerRecorder) AddPartition(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "AddPartition", arg0, arg1, arg2)
}

func (_m *MockConsumer) Close() error {
	ret := _m.ctrl.Call(_m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockConsumerRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

func (_m *MockConsumer) Commit(_param0 string, _param1 int32, _param2 int64) error {
	ret := _m.ctrl.Call(_m, "Commit", _param0, _param1, _param2)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockConsumerRecorder) Commit(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Commit", arg0, arg1, arg2)
}

func (_m *MockConsumer) Events() <-chan kafka.Event {
	ret := _m.ctrl.Call(_m, "Events")
	ret0, _ := ret[0].(<-chan kafka.Event)
	return ret0
}

func (_mr *_MockConsumerRecorder) Events() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Events")
}

func (_m *MockConsumer) RemovePartition(_param0 string, _param1 int32) error {
	ret := _m.ctrl.Call(_m, "RemovePartition", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockConsumerRecorder) RemovePartition(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "RemovePartition", arg0, arg1)
}

func (_m *MockConsumer) Subscribe(_param0 map[string]int64) error {
	ret := _m.ctrl.Call(_m, "Subscribe", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockConsumerRecorder) Subscribe(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Subscribe", arg0)
}

// Mock of TopicManager interface
type MockTopicManager struct {
	ctrl     *gomock.Controller
	recorder *_MockTopicManagerRecorder
}

// Recorder for MockTopicManager (not exported)
type _MockTopicManagerRecorder struct {
	mock *MockTopicManager
}

func NewMockTopicManager(ctrl *gomock.Controller) *MockTopicManager {
	mock := &MockTopicManager{ctrl: ctrl}
	mock.recorder = &_MockTopicManagerRecorder{mock}
	return mock
}

func (_m *MockTopicManager) EXPECT() *_MockTopicManagerRecorder {
	return _m.recorder
}

func (_m *MockTopicManager) Close() error {
	ret := _m.ctrl.Call(_m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTopicManagerRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

func (_m *MockTopicManager) EnsureStreamExists(_param0 string, _param1 int) error {
	ret := _m.ctrl.Call(_m, "EnsureStreamExists", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTopicManagerRecorder) EnsureStreamExists(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "EnsureStreamExists", arg0, arg1)
}

func (_m *MockTopicManager) EnsureTableExists(_param0 string, _param1 int) error {
	ret := _m.ctrl.Call(_m, "EnsureTableExists", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTopicManagerRecorder) EnsureTableExists(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "EnsureTableExists", arg0, arg1)
}

func (_m *MockTopicManager) Partitions(_param0 string) ([]int32, error) {
	ret := _m.ctrl.Call(_m, "Partitions", _param0)
	ret0, _ := ret[0].([]int32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockTopicManagerRecorder) Partitions(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Partitions", arg0)
}

// Mock of Producer interface
type MockProducer struct {
	ctrl     *gomock.Controller
	recorder *_MockProducerRecorder
}

// Recorder for MockProducer (not exported)
type _MockProducerRecorder struct {
	mock *MockProducer
}

func NewMockProducer(ctrl *gomock.Controller) *MockProducer {
	mock := &MockProducer{ctrl: ctrl}
	mock.recorder = &_MockProducerRecorder{mock}
	return mock
}

func (_m *MockProducer) EXPECT() *_MockProducerRecorder {
	return _m.recorder
}

func (_m *MockProducer) Close() error {
	ret := _m.ctrl.Call(_m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockProducerRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

func (_m *MockProducer) Emit(_param0 string, _param1 string, _param2 []byte) *kafka.Promise {
	ret := _m.ctrl.Call(_m, "Emit", _param0, _param1, _param2)
	ret0, _ := ret[0].(*kafka.Promise)
	return ret0
}

func (_mr *_MockProducerRecorder) Emit(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Emit", arg0, arg1, arg2)
}
